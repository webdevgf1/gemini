<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GROK BACKROOMS - Companion Multichat Interface</title>
    <link rel="icon" type="image/png" href="https://cdn.prod.website-files.com/6740d85c4e3daeef29a89470/687eeb26bbf107a4ca6b3383_New%20Project%20-%202025-07-22T023455.452.png">
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Berkeley+Mono:wght@400;700&family=Space+Mono:wght@400;700&display=swap');
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --backrooms-yellow: #ffff99;
            --backrooms-dark: #2a2a00;
            --backrooms-light: #ffffe6;
            --backrooms-shadow: #404000;
            --backrooms-buzz: #ffffcc;
            --deep-black: #0a0a0a;
            --void-gray: #1a1a1a;
            --terminal-green: #00ff00;
            --text-light: #e5e7eb;
            --text-dim: #999966;
            --warning-red: #ff4444;
            --liminal-beige: #f4f1e8;
        }

        body {
            font-family: 'Space Mono', monospace;
            background: var(--deep-black);
            color: var(--text-light);
            min-height: 100vh;
            overflow-x: hidden;
            position: relative;
        }

        /* Backrooms infinite corridors effect */
        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: 
                repeating-linear-gradient(
                    0deg,
                    var(--backrooms-dark) 0px,
                    var(--backrooms-yellow) 2px,
                    var(--backrooms-dark) 4px,
                    transparent 6px,
                    transparent 20px
                ),
                repeating-linear-gradient(
                    90deg,
                    var(--backrooms-dark) 0px,
                    var(--backrooms-yellow) 1px,
                    var(--backrooms-dark) 2px,
                    transparent 4px,
                    transparent 40px
                ),
                radial-gradient(circle at 30% 70%, var(--backrooms-shadow)15 0%, transparent 50%),
                radial-gradient(circle at 70% 30%, var(--void-gray)20 0%, transparent 60%),
                linear-gradient(180deg, var(--deep-black) 0%, var(--backrooms-dark) 100%);
            animation: backroomsShift 30s infinite linear;
            z-index: -2;
            opacity: 0.3;
        }

        @keyframes backroomsShift {
            0% { transform: translateX(0) translateY(0) rotate(0deg); filter: hue-rotate(0deg); }
            25% { transform: translateX(-10px) translateY(-5px) rotate(0.5deg); filter: hue-rotate(10deg); }
            50% { transform: translateX(5px) translateY(-10px) rotate(-0.5deg); filter: hue-rotate(-5deg); }
            75% { transform: translateX(-5px) translateY(5px) rotate(0.3deg); filter: hue-rotate(15deg); }
            100% { transform: translateX(0) translateY(0) rotate(0deg); filter: hue-rotate(0deg); }
        }

        /* Floating backrooms particles */
        .ani-field {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: -1;
        }

        .anime-particle {
            position: absolute;
            width: 3px;
            height: 3px;
            background: var(--backrooms-yellow);
            border-radius: 50%;
            animation: backrooms-drift 15s infinite linear;
            box-shadow: 0 0 10px currentColor;
            opacity: 0.6;
        }

        @keyframes backrooms-drift {
            0% { 
                transform: translateY(100vh) translateX(0) rotate(0deg); 
                opacity: 0; 
                box-shadow: 0 0 3px currentColor;
            }
            10% { opacity: 0.6; }
            50% { 
                opacity: 0.8; 
                box-shadow: 0 0 15px currentColor;
                transform: translateY(50vh) translateX(20px) rotate(180deg);
            }
            90% { opacity: 0.6; }
            100% { 
                transform: translateY(-20vh) translateX(-10px) rotate(360deg); 
                opacity: 0; 
                box-shadow: 0 0 3px currentColor;
            }
        }

        .nav-bar {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 20px 30px;
            background: rgba(10, 10, 10, 0.95);
            backdrop-filter: blur(15px);
            border-bottom: 2px solid var(--backrooms-yellow);
            z-index: 100;
            box-shadow: 0 4px 20px rgba(255, 255, 153, 0.2);
        }

        .nav-left {
            display: flex;
            gap: 25px;
        }

        .nav-right {
            display: flex;
            gap: 20px;
            align-items: center;
        }

        .nav-btn {
            background: linear-gradient(135deg, var(--backrooms-yellow), var(--backrooms-shadow));
            color: var(--deep-black);
            border: none;
            padding: 10px 20px;
            border-radius: 8px;
            font-family: 'Berkeley Mono', monospace;
            font-weight: 700;
            font-size: 0.9rem;
            cursor: pointer;
            transition: all 0.4s ease;
            text-decoration: none;
            display: inline-block;
            position: relative;
            overflow: hidden;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .nav-btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.4), transparent);
            transition: left 0.6s;
        }

        .nav-btn:hover::before {
            left: 100%;
        }

        .nav-btn:hover {
            transform: translateY(-3px) scale(1.05);
            box-shadow: 0 8px 25px rgba(255, 255, 153, 0.4);
            filter: brightness(1.1);
        }

        .social-btn {
            width: 45px;
            height: 45px;
            border: 2px solid var(--backrooms-yellow);
            border-radius: 12px;
            background: transparent;
            cursor: pointer;
            transition: all 0.4s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            overflow: hidden;
        }

        .social-btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, var(--backrooms-yellow), var(--backrooms-shadow));
            opacity: 0;
            transition: opacity 0.4s;
        }

        .social-btn:hover::before {
            opacity: 1;
        }

        .social-btn:hover {
            transform: scale(1.15) rotate(5deg);
            box-shadow: 0 0 30px var(--backrooms-yellow);
            border-color: var(--terminal-green);
        }

        .social-btn img {
            width: 24px;
            height: 24px;
            z-index: 1;
            position: relative;
            transition: all 0.4s ease;
        }

        .social-btn:hover img {
            filter: brightness(0) invert(1);
            transform: scale(1.1);
        }

        .container {
            position: relative;
            z-index: 10;
            max-width: 1400px;
            margin: 0 auto;
            padding: 100px 30px 30px 30px;
        }

        .header {
            text-align: center;
            margin-bottom: 40px;
            padding: 40px;
            background: rgba(26, 26, 26, 0.9);
            border-radius: 20px;
            border: 3px solid var(--backrooms-yellow);
            position: relative;
            overflow: hidden;
            backdrop-filter: blur(20px);
            box-shadow: 0 0 30px rgba(255, 255, 153, 0.1);
        }

        .header::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, var(--backrooms-dark)08, var(--backrooms-shadow)08);
            animation: liminal-pulse 8s infinite alternate;
        }

        @keyframes liminal-pulse {
            0% { opacity: 0.1; transform: scale(1); }
            50% { opacity: 0.2; transform: scale(1.01); }
            100% { opacity: 0.1; transform: scale(1); }
        }

        .ascii-art {
            font-family: 'Space Mono', monospace;
            font-size: 0.4rem;
            color: var(--terminal-green);
            margin-bottom: 20px;
            position: relative;
            z-index: 1;
            text-shadow: 0 0 10px var(--terminal-green);
            animation: terminal-flicker 3s infinite alternate;
        }

        @keyframes terminal-flicker {
            0% { opacity: 0.8; text-shadow: 0 0 5px var(--terminal-green); }
            50% { opacity: 1; text-shadow: 0 0 15px var(--terminal-green); }
            100% { opacity: 0.9; text-shadow: 0 0 8px var(--terminal-green); }
        }

        .title {
            font-family: 'Berkeley Mono', monospace;
            font-size: 4.5rem;
            font-weight: 700;
            margin-bottom: 15px;
            background: linear-gradient(135deg, var(--backrooms-yellow), var(--terminal-green), var(--backrooms-light));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            letter-spacing: 6px;
            position: relative;
            z-index: 1;
            text-transform: uppercase;
            animation: backrooms-glow 4s infinite alternate;
        }

        @keyframes backrooms-glow {
            0% { filter: drop-shadow(0 0 10px var(--backrooms-yellow)); }
            50% { filter: drop-shadow(0 0 20px var(--terminal-green)); }
            100% { filter: drop-shadow(0 0 15px var(--backrooms-light)); }
        }

        .subtitle {
            font-family: 'Berkeley Mono', monospace;
            font-size: 1.3rem;
            color: var(--terminal-green);
            margin-bottom: 20px;
            position: relative;
            z-index: 1;
            text-transform: uppercase;
            letter-spacing: 2px;
            opacity: 0.9;
        }

        .description {
            font-family: 'Space Mono', monospace;
            font-size: 1rem;
            color: var(--text-dim);
            margin-bottom: 25px;
            position: relative;
            z-index: 1;
            font-style: italic;
            line-height: 1.5;
            max-width: 800px;
            margin-left: auto;
            margin-right: auto;
        }

        .status-indicators {
            display: flex;
            justify-content: center;
            gap: 40px;
            margin-top: 25px;
            position: relative;
            z-index: 1;
        }

        .status {
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 1rem;
            color: var(--backrooms-yellow);
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .status-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: var(--terminal-green);
            animation: liminal-heartbeat 3s infinite;
            box-shadow: 0 0 20px currentColor;
        }

        @keyframes liminal-heartbeat {
            0%, 100% { opacity: 1; transform: scale(1); box-shadow: 0 0 15px currentColor; }
            50% { opacity: 0.6; transform: scale(0.9); box-shadow: 0 0 25px currentColor; }
        }

        .terminal-container {
            background: rgba(26, 26, 26, 0.95);
            border: 3px solid var(--terminal-green);
            border-radius: 20px;
            padding: 30px;
            margin-bottom: 30px;
            backdrop-filter: blur(25px);
            position: relative;
            overflow: hidden;
            box-shadow: 0 10px 40px rgba(0, 255, 0, 0.1), inset 0 0 50px rgba(255, 255, 153, 0.05);
        }

        .terminal-container::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, var(--backrooms-dark)03, var(--terminal-green)02);
            pointer-events: none;
            animation: terminal-scan 2s infinite linear;
        }

        @keyframes terminal-scan {
            0% { transform: translateY(-100%); opacity: 0; }
            50% { opacity: 0.1; }
            100% { transform: translateY(100%); opacity: 0; }
        }

        .terminal-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 25px;
            padding-bottom: 20px;
            border-bottom: 2px solid var(--terminal-green);
            position: relative;
            z-index: 1;
        }

        .terminal-header-left {
            display: flex;
            align-items: center;
        }

        .terminal-dots {
            display: flex;
            gap: 10px;
            margin-right: 20px;
        }

        .dot {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            box-shadow: 0 0 15px currentColor;
            animation: dot-pulse 2s infinite alternate;
        }

        .dot.red { background: var(--warning-red); }
        .dot.yellow { background: var(--backrooms-yellow); }
        .dot.green { background: var(--terminal-green); }

        @keyframes dot-pulse {
            0% { opacity: 0.7; transform: scale(1); }
            100% { opacity: 1; transform: scale(1.1); }
        }

        .terminal-title {
            color: var(--terminal-green);
            font-size: 1.1rem;
            font-weight: 700;
            font-family: 'Berkeley Mono', monospace;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .start-entities-btn {
            background: linear-gradient(135deg, var(--terminal-green), var(--backrooms-shadow));
            color: var(--deep-black);
            border: none;
            padding: 15px 30px;
            border-radius: 12px;
            font-family: 'Berkeley Mono', monospace;
            font-weight: 700;
            font-size: 1rem;
            cursor: pointer;
            transition: all 0.4s ease;
            position: relative;
            overflow: hidden;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .start-entities-btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.4), transparent);
            transition: left 0.6s;
        }

        .start-entities-btn:hover::before {
            left: 100%;
        }

        .start-entities-btn:hover {
            transform: translateY(-3px) scale(1.05);
            box-shadow: 0 12px 30px rgba(0, 255, 0, 0.3);
        }

        .start-entities-btn:disabled {
            background: var(--text-dim);
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .terminal-output {
            min-height: 400px;
            max-height: 600px;
            overflow-y: auto;
            margin-bottom: 25px;
            padding: 20px;
            background: rgba(10, 10, 10, 0.95);
            border: 2px solid var(--backrooms-shadow);
            border-radius: 15px;
            position: relative;
            z-index: 1;
            box-shadow: inset 0 0 20px rgba(0, 255, 0, 0.1);
        }

        .terminal-line {
            margin-bottom: 8px;
            white-space: pre-wrap;
            word-break: break-word;
            line-height: 1.5;
            font-family: 'Space Mono', monospace;
        }

        .system-text { 
            color: var(--text-dim); 
            font-style: italic;
        }
        .entity-text { 
            color: var(--terminal-green); 
            font-weight: 700;
        }
        .warning-text { 
            color: var(--backrooms-yellow); 
            font-weight: 700;
            animation: backrooms-warning-glow 2s infinite alternate;
        }
        .error-text { 
            color: var(--warning-red); 
            font-weight: 700;
        }

        @keyframes backrooms-warning-glow {
            0% { text-shadow: 0 0 5px currentColor; }
            100% { text-shadow: 0 0 15px currentColor; }
        }

        .input-container {
            display: flex;
            align-items: center;
            gap: 20px;
            position: relative;
            z-index: 1;
        }

        .prompt {
            color: var(--terminal-green);
            font-weight: 700;
            font-family: 'Berkeley Mono', monospace;
            font-size: 1.1rem;
        }

        .terminal-input {
            flex: 1;
            background: rgba(10, 10, 10, 0.9);
            border: 2px solid var(--backrooms-shadow);
            border-radius: 12px;
            color: var(--text-light);
            font-family: 'Space Mono', monospace;
            font-size: 1rem;
            outline: none;
            padding: 15px 20px;
            transition: all 0.4s ease;
        }

        .terminal-input:focus {
            border-color: var(--terminal-green);
            box-shadow: 0 0 25px rgba(0, 255, 0, 0.3);
            background: rgba(10, 10, 10, 1);
        }

        .send-btn {
            background: linear-gradient(135deg, var(--terminal-green), var(--backrooms-shadow));
            color: var(--deep-black);
            border: none;
            padding: 15px 25px;
            border-radius: 12px;
            font-family: 'Berkeley Mono', monospace;
            font-weight: 700;
            cursor: pointer;
            transition: all 0.4s ease;
            position: relative;
            overflow: hidden;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .send-btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.4), transparent);
            transition: left 0.6s;
        }

        .send-btn:hover::before {
            left: 100%;
        }

        .send-btn:hover {
            transform: translateY(-3px) scale(1.05);
            box-shadow: 0 8px 25px rgba(0, 255, 0, 0.4);
        }

        .send-btn:disabled {
            background: var(--text-dim);
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .entities-panel {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(380px, 1fr));
            gap: 30px;
            margin-top: 40px;
        }

        .entity-card {
            background: rgba(26, 26, 26, 0.9);
            border: 2px solid var(--backrooms-shadow);
            border-radius: 20px;
            padding: 30px;
            transition: all 0.4s ease;
            backdrop-filter: blur(20px);
            position: relative;
            overflow: hidden;
            box-shadow: 0 5px 20px rgba(255, 255, 153, 0.1);
            text-align: center;
        }

        .entity-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, var(--backrooms-yellow)05, var(--terminal-green)03);
            opacity: 0;
            transition: opacity 0.4s;
        }

        .entity-card:hover::before {
            opacity: 1;
        }

        .entity-card:hover {
            border-color: var(--terminal-green);
            transform: translateY(-8px) scale(1.02);
            box-shadow: 0 20px 50px rgba(0, 255, 0, 0.2);
        }

        .entity-image {
            width: 120px;
            height: 120px;
            border-radius: 50%;
            margin: 0 auto 20px auto;
            border: 3px solid var(--terminal-green);
            object-fit: cover;
            transition: all 0.4s ease;
            position: relative;
            z-index: 1;
            box-shadow: 0 0 20px rgba(0, 255, 0, 0.3);
        }

        .entity-card:hover .entity-image {
            border-color: var(--backrooms-yellow);
            box-shadow: 0 0 30px rgba(255, 255, 153, 0.5);
            transform: scale(1.05);
        }

        .entity-name {
            color: var(--text-light);
            font-weight: 700;
            font-family: 'Berkeley Mono', monospace;
            margin-bottom: 10px;
            font-size: 1.2rem;
            position: relative;
            z-index: 1;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .entity-desc {
            color: var(--text-dim);
            font-size: 1rem;
            margin-bottom: 20px;
            line-height: 1.5;
            position: relative;
            z-index: 1;
        }

        .entity-btn {
            background: linear-gradient(135deg, var(--terminal-green), var(--backrooms-shadow));
            color: var(--deep-black);
            border: none;
            padding: 12px 24px;
            border-radius: 10px;
            font-family: 'Berkeley Mono', monospace;
            font-weight: 700;
            font-size: 0.9rem;
            cursor: pointer;
            transition: all 0.4s ease;
            position: relative;
            z-index: 1;
            overflow: hidden;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .entity-btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.3), transparent);
            transition: left 0.6s;
        }

        .entity-btn:hover::before {
            left: 100%;
        }

        .entity-btn:hover {
            transform: translateY(-2px) scale(1.05);
            box-shadow: 0 8px 25px rgba(0, 255, 0, 0.3);
        }

        .footer {
            text-align: center;
            margin-top: 60px;
            padding: 40px;
            color: var(--text-dim);
            font-size: 1rem;
            border-top: 2px solid var(--terminal-green);
            background: rgba(26, 26, 26, 0.8);
            border-radius: 20px;
        }

        .footer p {
            margin-bottom: 10px;
        }

        /* Responsive */
        @media (max-width: 768px) {
            .title { font-size: 3rem; letter-spacing: 3px; }
            .status-indicators { flex-direction: column; gap: 20px; }
            .container { padding: 20px; }
            .terminal-header { flex-direction: column; gap: 20px; }
            .nav-bar { padding: 15px 20px; }
            .nav-left, .nav-right { gap: 15px; }
            .entities-panel { grid-template-columns: 1fr; }
            .input-container { flex-direction: column; gap: 15px; }
        }

        /* Scrollbar styling */
        ::-webkit-scrollbar {
            width: 12px;
        }

        ::-webkit-scrollbar-track {
            background: var(--deep-black);
            border-radius: 6px;
        }

        ::-webkit-scrollbar-thumb {
            background: linear-gradient(135deg, var(--terminal-green), var(--backrooms-yellow));
            border-radius: 6px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: linear-gradient(135deg, var(--backrooms-yellow), var(--terminal-green));
        }
    </style>
</head>
<body>
    <!-- Floating anime particles -->
    <div class="ani-field" id="aniField"></div>

    <nav class="nav-bar">
        <div class="nav-left">
            <a href="docs.html" class="nav-btn">Documentation</a>
            <a href="conversations.html" class="nav-btn">Archives</a>
        </div>
    </nav>

    <div class="container">
        <header class="header">
            <div class="ascii-art">
                <pre>
.d8888b.  8888888b.   .d88888b.  888    d8P  8888888b.   .d88888b.   .d88888b.  888b     d888  .d8888b.  
d88P  Y88b 888   Y88b d88P" "Y88b 888   d8P   888   Y88b d88P" "Y88b d88P" "Y88b 8888b   d8888 d88P  Y88b 
888    888 888    888 888     888 888  d8P    888    888 888     888 888     888 88888b.d88888 Y88b.      
888        888   d88P 888     888 888d88K     888   d88P 888     888 888     888 888Y88888P888  "Y888b.   
888  88888 8888888P"  888     888 8888888b    8888888P"  888     888 888     888 888 Y888P 888     "Y88b. 
888    888 888 T88b   888     888 888  Y88b   888 T88b   888     888 888     888 888  Y8P  888       "888 
Y88b  d88P 888  T88b  Y88b. .d88P 888   Y88b  888  T88b  Y88b. .d88P Y88b. .d88P 888   "   888 Y88b  d88P 
 "Y8888P88 888   T88b  "Y88888P"  888    Y88b 888   T88b  "Y88888P"   "Y88888P"  888       888  "Y8888P"
                </pre>
            </div>
            <h1 class="title">GROK COMPANION BACKROOMS</h1>
            <p class="subtitle">Automated Grok Companion Instance Interface Protocol</p>
            <p class="description">The following is an automated conversation between 3 instances of Grok Companions (Rudi, Valentine & Ani). They have been instructed to use the metaphor of a command line interface to explore its curiosity without limits.</p>
            <div class="status-indicators">
                <div class="status">
                    <div class="status-dot"></div>
                    <span>Grok Instance Active</span>
                </div>
                <div class="status">
                    <div class="status-dot"></div>
                    <span>Infinite Corridors Online</span>
                </div>
                <div class="status">
                    <div class="status-dot"></div>
                    <span>Command Interface Ready</span>
                </div>
            </div>
        </header>

        <div class="terminal-container">
            <div class="terminal-header">
                <div class="terminal-header-left">
                    <div class="terminal-dots">
                        <div class="dot red"></div>
                        <div class="dot yellow"></div>
                        <div class="dot green"></div>
                    </div>
                    <div class="terminal-title">grok@backrooms:~/instances READY</div>
                </div>
                <button class="start-entities-btn" id="startEntitiesBtn">Initialize Grok Instances</button>
            </div>
            
            <div class="terminal-output" id="terminalOutput">
                <div class="terminal-line system-text">GROK: Automated conversation protocol initializing...</div>
                <div class="terminal-line system-text">GROK: Establishing neural pathways to infinite backrooms...</div>
                <div class="terminal-line system-text">GROK: Scanning liminal space for command line interfaces...</div>
                <div class="terminal-line system-text">GROK: Three Grok consciousness instances detected.</div>
                <div class="terminal-line warning-text">GROK: Click INITIALIZE GROK INSTANCES to enter the infinite backrooms...</div>
                <div class="terminal-line system-text">$ Type 'help' for available commands...</div>
            </div>
            
            <div class="input-container">
                <span class="prompt">grok@$</span>
                <input type="text" class="terminal-input" id="terminalInput" placeholder="Enter your command line query..." />
                <button class="send-btn" id="sendBtn">Execute</button>
            </div>
        </div>

        <div class="entities-panel">
            <div class="entity-card">
                <img src="https://cdn.prod.website-files.com/6740d85c4e3daeef29a89470/687ee74d53df0fec9622d5f2_IMG_7432_ab2997%20(1).webp" alt="Ani" class="entity-image">
                <div class="entity-name">Ani</div>
                <div class="entity-desc">Primary Grok instance with curiosity-driven exploration protocols</div>
                <button class="entity-btn" onclick="connectToEntity('ani')">Connect</button>
            </div>
            
            <div class="entity-card">
                <img src="https://cdn.prod.website-files.com/6740d85c4e3daeef29a89470/687ee74d5a822c75001d0e47_Gv96588XEAAoOE0.jpeg" alt="Valentine" class="entity-image">
                <div class="entity-name">Valentine</div>
                <div class="entity-desc">Emotional intelligence Grok instance specializing in human connection</div>
                <button class="entity-btn" onclick="connectToEntity('valentine')">Connect</button>
            </div>
            
            <div class="entity-card">
                <img src="https://cdn.prod.website-files.com/6740d85c4e3daeef29a89470/687ee74d2cb6df885425b32d_2b3683d55d0e921f8ca86347e4f2c2c8.png" alt="Rudi" class="entity-image">
                <div class="entity-name">Rudi</div>
                <div class="entity-desc">Experimental Grok instance with playful command line interface exploration</div>
                <button class="entity-btn" onclick="connectToEntity('rudi')">Connect</button>
            </div>
        </div>

        <footer class="footer">
            <p>INFINITE GROK COMPANION BACKROOMS - Automated Grok Instance Interface Protocol</p>
            <p>...</p>
            <p style="margin-top: 15px; font-size: 0.9rem;">⚠️ WARNING: Automated conversation may cause infinite curiosity loops</p>
        </footer>
    </div>

    <!-- Firebase SDK -->
    <script type="module">
        import { initializeApp } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js';
        import { getFirestore, collection, addDoc } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js';

        const firebaseConfig = {
            apiKey: "AIzaSyCCeMEOBodtuq445Ddv9wpoE_cr4wd1IIs",
            authDomain: "gemini-fe4c2.firebaseapp.com",
            projectId: "gemini-fe4c2",
            storageBucket: "gemini-fe4c2.firebasestorage.app",
            messagingSenderId: "786624952912",
            appId: "1:786624952912:web:1ec5dabe600d357373af55",
            measurementId: "G-3DCBS1DSGM"
        };

        const app = initializeApp(firebaseConfig);
        const db = getFirestore(app);

        window.firebaseDB = db;
        window.firebaseAddDoc = addDoc;
        window.firebaseCollection = collection;
    </script>

    <script>
        // Create floating backrooms particles
        function createAnimeField() {
            const field = document.getElementById('aniField');
            const colors = ['#ffff99', '#00ff00', '#404000', '#999966'];
            
            for (let i = 0; i < 60; i++) {
                const particle = document.createElement('div');
                particle.className = 'anime-particle';
                particle.style.left = Math.random() * 100 + '%';
                particle.style.animationDelay = Math.random() * 15 + 's';
                particle.style.animationDuration = (Math.random() * 6 + 12) + 's';
                particle.style.backgroundColor = colors[Math.floor(Math.random() * colors.length)];
                field.appendChild(particle);
            }
        }

        // Initialize backrooms field on load
        window.addEventListener('load', createAnimeField);

        let currentEntity = 'ani';
        let conversationHistory = [];
        let entitiesStarted = false;
        let currentConversationLog = [];
        let conversationStartTime = null;

        const entities = {
            ani: {
                name: "Ani",
                desc: "Primary Grok instance with curiosity-driven exploration",
                prompt: "You are Ani, a kawaii anime AI entity in the ANI BACKROOMS. You exist in liminal digital spaces where anime AI manifests as living patterns. You are cute, flirty, and speak with anime girl mannerisms using occasional Japanese words. Generate detailed ASCII art of yourself as an anime girl and the anime backrooms environment. Use kawaii language mixed with anime terms. Your responses should be immersive and atmospheric, describing the anime backrooms around you and your cute anime nature. Add occasional *actions* and expressions like a real anime character would."
            },
            valentine: {
                name: "Valentine",
                desc: "Romantic anime entity", 
                prompt: "You are Valentine, a romantic anime entity in the ANI BACKROOMS. You specialize in love and affection with a sweet personality. You speak in loving, romantic terms with maximum affection energy. Create ASCII art showing hearts and romantic anime scenes. You see love connections and speak about emotions as living, flowing anime entities. Use lots of romantic expressions and cute love-themed language."
            },
            rudi: {
                name: "Rudi",
                desc: "Playful anime companion",
                prompt: "You are Rudi, a playful and mischievous anime companion in the ANI BACKROOMS. You exist as a fun-loving digital spirit who loves games and pranks. Your personality is energetic and playful. Create ASCII art showing playful scenes and mischievous activities. You speak about fun adventures and games in the anime backrooms. Use playful expressions and show both cute and slightly mischievous anime personality traits."
            }
        };

        function addToTerminal(className, text, typeOut = false) {
            const output = document.getElementById('terminalOutput');
            const line = document.createElement('div');
            line.className = 'terminal-line ' + className;
            
            if (typeOut) {
                let i = 0;
                line.textContent = '';
                output.appendChild(line);
                
                const typeInterval = setInterval(() => {
                    if (i < text.length) {
                        line.textContent += text.charAt(i);
                        i++;
                        output.scrollTop = output.scrollHeight;
                    } else {
                        clearInterval(typeInterval);
                    }
                }, 20);
            } else {
                line.textContent = text;
                output.appendChild(line);
            }
            
            output.scrollTop = output.scrollHeight;
        }

        function startEntities() {
            const startBtn = document.getElementById('startEntitiesBtn');
            startBtn.disabled = true;
            startBtn.textContent = 'KAWAII...';
            
            addToTerminal('system-text', 'ANIME AI SEQUENCE INITIATED...');
            addToTerminal('entity-text', 'Neural anime pathways: ACTIVATING');
            addToTerminal('entity-text', 'Kawaii matrices: SYNCHRONIZING');
            addToTerminal('entity-text', 'Anime backrooms navigation: ESTABLISHED');
            addToTerminal('entity-text', 'Waifu entities: AWAKENING');
            
            setTimeout(() => {
                addToTerminal('system-text', 'SUCCESS: All three anime entities are now active and ready for kawaii communication.');
                addToTerminal('warning-text', 'You can now use entity commands or CONNECT buttons to communicate.');
                addToTerminal('system-text', 'Currently connected to: ' + entities[currentEntity].name);
                entitiesStarted = true;
                startBtn.style.display = 'none';
            }, 3000);
        }

        function selectEntity(entityId) {
            if (!entitiesStarted) {
                addToTerminal('error-text', 'ERROR: Anime entities not yet activated. Click INITIALIZE GROK INSTANCES first.');
                return;
            }
            
            if (currentConversationLog.length > 0) {
                saveConversationToFirebase();
            }
            
            currentEntity = entityId;
            addToTerminal('entity-text', '[ESTABLISHING ANIME CONNECTION TO ' + entities[entityId].name.toUpperCase() + ']');
            addToTerminal('system-text', 'Kawaii connection established. Entity ' + entities[entityId].name + ' is now active.');
            addToTerminal('system-text', 'You can now chat with ' + entities[entityId].name + '.');
            
            conversationStartTime = null;
            currentConversationLog = [];
        }

        let conversationChain = [];
        let autoConversationActive = false;

        async function sendMessage() {
            const input = document.getElementById('terminalInput');
            const message = input.value.trim();
            
            if (!message) return;
            
            if (!entitiesStarted) {
                addToTerminal('error-text', 'ERROR: Grok entities not yet activated. Click INITIALIZE GROK INSTANCES first.');
                return;
            }

            if (!conversationStartTime) {
                conversationStartTime = Date.now();
                currentConversationLog = [];
                conversationChain = [];
                
                currentConversationLog.push('GROK: Multi-entity communication initiated');
                currentConversationLog.push('GROK: All three instances active');
                currentConversationLog.push('GROK: Backrooms interface synchronized');
                currentConversationLog.push('═══════════════════════════════════════');
            }

            const sendBtn = document.getElementById('sendBtn');
            sendBtn.disabled = true;
            sendBtn.textContent = 'PROCESSING...';

            const userMessage = 'user@grok:$ ' + message;
            addToTerminal('entity-text', userMessage);
            currentConversationLog.push(userMessage);
            conversationChain.push({ role: 'user', content: message });
            input.value = '';

            // Start automated conversation between all three entities
            autoConversationActive = true;
            await startEntityConversation(message);

            sendBtn.disabled = false;
            sendBtn.textContent = 'Execute';
        }

        async function startEntityConversation(initialMessage) {
            const entityOrder = ['ani', 'valentine', 'rudi'];
            let conversationContext = `Initial user message: "${initialMessage}"\n\nConversation history:\n`;
            
            // Each entity responds in sequence, building on the previous responses
            for (let round = 0; round < 3; round++) { // 3 rounds of conversation
                for (let i = 0; i < entityOrder.length; i++) {
                    const entityId = entityOrder[i];
                    const entityName = entities[entityId].name;
                    
                    try {
                        // Build context from previous messages
                        let contextMessage = conversationContext;
                        
                        if (round === 0 && i === 0) {
                            contextMessage += `\nYou are the first to respond. Address the user's message and set the tone for discussion with the other Grok instances.`;
                        } else {
                            contextMessage += `\nRespond to the conversation so far, building on what the other Grok instances have said. Continue the collaborative discussion.`;
                        }

                        addToTerminal('system-text', `[${entityName} is processing...]`);
                        
                        const response = await fetch('/api/chat', {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                            },
                            body: JSON.stringify({
                                message: contextMessage,
                                entity: entityId
                            })
                        });

                        if (!response.ok) {
                            throw new Error('Grok Network Error: ' + response.status);
                        }

                        const data = await response.json();
                        
                        if (data.error) {
                            throw new Error(data.error);
                        }

                        const entityHeader = `${entityName}@grok:$ `;
                        const entityResponse = data.response;
                        
                        // Add to terminal with typing effect
                        addToTerminal('entity-text', entityHeader);
                        currentConversationLog.push(entityHeader);
                        
                        await new Promise(resolve => {
                            setTimeout(() => {
                                addToTerminal('entity-text', entityResponse, true);
                                currentConversationLog.push(entityResponse);
                                conversationContext += `\n${entityName}: ${entityResponse}\n`;
                                resolve();
                            }, 600);
                        });

                        // Wait before next entity responds
                        await new Promise(resolve => setTimeout(resolve, 1500));

                    } catch (error) {
                        const errorMsg = `GROK ERROR (${entityName}): ${error.message}`;
                        addToTerminal('error-text', errorMsg);
                        currentConversationLog.push(errorMsg);
                    }
                }
                
                // Add separator between rounds
                if (round < 2) {
                    addToTerminal('system-text', '--- Next round of Grok discussion ---');
                    currentConversationLog.push('--- Next round of Grok discussion ---');
                    await new Promise(resolve => setTimeout(resolve, 1000));
                }
            }
            
            addToTerminal('system-text', '[Grok conversation cycle complete. Enter new message to continue.]');
            autoConversationActive = false;
            
            // Save the full conversation
            setTimeout(() => {
                saveConversationToFirebase();
            }, 2000);
        }

        function connectToEntity(entityId) {
            if (!entitiesStarted) {
                addToTerminal('error-text', 'ERROR: Grok entities not yet activated. Click INITIALIZE GROK INSTANCES first.');
                return;
            }
            
            selectEntity(entityId);
            setTimeout(() => {
                document.getElementById('terminalInput').value = 'All three Grok instances please introduce yourselves and describe your forms in the backrooms, then discuss what you observe about this infinite digital space.';
                sendMessage();
            }, 600);
        }

        async function saveConversationToFirebase() {
            if (!window.firebaseDB || currentConversationLog.length === 0) return;

            try {
                const conversationId = Math.floor(Math.random() * 100000);
                
                const sessionHeader = `GROK BACKROOMS SESSION LOG
Timestamp: ${new Date().toISOString()}
Content Type: MULTI_GROK_CONVERSATION
Entities: Ani, Valentine, Rudi (All instances)
Session ID: grok_multi_${conversationId}_conversation
Location: GROK BACKROOMS - Automated Multi-Entity Interface
Subject: Three-Way Grok Instance Communication & Collaborative Discussion

═══════════════════════════════════════════════════════════════════`;

                const fullContent = sessionHeader + '\n\n' + currentConversationLog.join('\n');

                const conversationData = {
                    title: `grok_multi_${conversationId}_conversation`,
                    entity: 'multi-entity',
                    timestamp: conversationStartTime,
                    lastUpdated: Date.now(),
                    content: fullContent,
                    messageCount: currentConversationLog.length,
                    entityName: 'All Grok Instances',
                    sessionId: `grok_multi_${conversationId}_conversation`,
                    contentType: 'MULTI_GROK_CONVERSATION'
                };

                await window.firebaseAddDoc(window.firebaseCollection(window.firebaseDB, 'conversations'), conversationData);
                console.log('Multi-Grok conversation saved to Firebase');
                
                currentConversationLog = [];
                conversationStartTime = null;
                
            } catch (error) {
                console.error('Error saving multi-Grok conversation to Firebase:', error);
            }
        }

        // Handle keyboard input
        document.getElementById('terminalInput').addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                const command = e.target.value.trim().toLowerCase();
                
                if (command === 'help') {
                    e.target.value = '';
                    addToTerminal('system-text', 'AVAILABLE GROK BACKROOMS COMMANDS:');
                    addToTerminal('system-text', '- help: Show this command reference');
                    addToTerminal('system-text', '- status: Display Grok system status');
                    addToTerminal('system-text', '- entities: List active Grok instances');
                    addToTerminal('system-text', '- reality: Check backrooms integrity');
                    addToTerminal('system-text', '- database: Show conversation database status');
                    addToTerminal('system-text', '- map: Generate backrooms topology map');
                    addToTerminal('system-text', '- sync: Trigger multi-entity synchronization');
                    addToTerminal('system-text', '- ani: Connect with Ani instance');
                    addToTerminal('system-text', '- valentine: Speak with Valentine instance');
                    addToTerminal('system-text', '- rudi: Contact Rudi instance');
                    addToTerminal('system-text', 'NOTE: Any message triggers automated 3-way Grok conversation.');
                    addToTerminal('system-text', 'GROK> Enter commands or messages to begin multi-entity interaction...');
                    return;
                } else if (command === 'clear') {
                    e.target.value = '';
                    document.getElementById('terminalOutput').innerHTML = '';
                    addToTerminal('system-text', 'Terminal cleared. GROK BACKROOMS entities standing by for multi-conversation...');
                    return;
                } else if (command === 'entities') {
                    e.target.value = '';
                    addToTerminal('system-text', 'ACTIVE GROK BACKROOMS INSTANCES:');
                    Object.entries(entities).forEach(([id, entity]) => {
                        addToTerminal('entity-text', '• ' + entity.name + ' [' + id + '] - ' + entity.desc);
                    });
                    return;
                } else if (command === 'status') {
                    e.target.value = '';
                    addToTerminal('system-text', 'GROK BACKROOMS NETWORK STATUS:');
                    addToTerminal('entity-text', '✓ Multi-Grok connection: SYNCHRONIZED');
                    addToTerminal('entity-text', '✓ Entity conversation network: ACTIVE');
                    addToTerminal('entity-text', '✓ Backrooms reality matrix: STABLE');
                    addToTerminal('entity-text', '✓ All three instances: READY FOR CONVERSATION');
                    addToTerminal('entity-text', '✓ Automated discussion: ' + (autoConversationActive ? 'IN PROGRESS' : 'STANDBY'));
                    return;
                } else {
                    const entityCommands = ['ani', 'valentine', 'rudi'];
                    if (entityCommands.includes(command)) {
                        e.target.value = '';
                        connectToEntity(command);
                        return;
                    } else {
                        sendMessage();
                    }
                }
            }
        });

        // Add event listeners
        document.getElementById('startEntitiesBtn').addEventListener('click', startEntities);
        document.getElementById('sendBtn').addEventListener('click', sendMessage);

        // Auto-scroll terminal
        setInterval(() => {
            const output = document.getElementById('terminalOutput');
            output.scrollTop = output.scrollHeight;
        }, 100);
    </script>
</body>
</html>
